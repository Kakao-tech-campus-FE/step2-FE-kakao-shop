{"ast":null,"code":"import { isCancelable } from './retryer';\nimport { getAbortController } from './utils';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var abortController = getAbortController();\n        var abortSignal = abortController == null ? void 0 : abortController.signal;\n        var newPageParams = oldPageParams;\n        var cancelled = false; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        };\n        var buildNewPages = function buildNewPages(pages, param, page, previous) {\n          newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n          return previous ? [page].concat(pages) : [].concat(pages, [page]);\n        }; // Create function to fetch a page\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            signal: abortSignal,\n            pageParam: param,\n            meta: context.meta\n          };\n          var queryFnResult = queryFn(queryFnContext);\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            return buildNewPages(pages, param, page, previous);\n          });\n          if (isCancelable(queryFnResult)) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = queryFnResult.cancel;\n          }\n          return promise;\n        };\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n          var manual = typeof pageParam !== 'undefined';\n          var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, manual, param);\n        } // Fetch previous page?\n        else if (isFetchingPreviousPage) {\n          var _manual = typeof pageParam !== 'undefined';\n          var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n          promise = fetchPage(oldPages, _manual, _param, true);\n        } // Refetch pages\n        else {\n          (function () {\n            newPageParams = [];\n            var manual = typeof context.options.getNextPageParam === 'undefined';\n            var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n            promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n            var _loop = function _loop(i) {\n              promise = promise.then(function (pages) {\n                var shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n                if (shouldFetchNextPage) {\n                  var _param2 = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n                  return fetchPage(pages, manual, _param2);\n                }\n                return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n              });\n            };\n            for (var i = 1; i < oldPages.length; i++) {\n              _loop(i);\n            }\n          })();\n        }\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n        var finalPromiseAsAny = finalPromise;\n        finalPromiseAsAny.cancel = function () {\n          cancelled = true;\n          abortController == null ? void 0 : abortController.abort();\n          if (isCancelable(promise)) {\n            promise.cancel();\n          }\n        };\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}","map":{"version":3,"names":["isCancelable","getAbortController","infiniteQueryBehavior","onFetch","context","fetchFn","_context$fetchOptions","_context$fetchOptions2","_context$fetchOptions3","_context$fetchOptions4","_context$state$data","_context$state$data2","refetchPage","fetchOptions","meta","fetchMore","pageParam","isFetchingNextPage","direction","isFetchingPreviousPage","oldPages","state","data","pages","oldPageParams","pageParams","abortController","abortSignal","signal","newPageParams","cancelled","queryFn","options","Promise","reject","buildNewPages","param","page","previous","concat","fetchPage","manual","length","resolve","queryFnContext","queryKey","queryFnResult","promise","then","promiseAsAny","cancel","getNextPageParam","_manual","_param","getPreviousPageParam","shouldFetchFirstPage","_loop","i","shouldFetchNextPage","_param2","finalPromise","finalPromiseAsAny","abort","hasNextPage","Array","isArray","nextPageParam","hasPreviousPage","previousPageParam"],"sources":["/Users/somingyeong/Documents/kakao/step2-FE-kakao-shop/step-2-week1/node_modules/react-query/es/core/infiniteQueryBehavior.js"],"sourcesContent":["import { isCancelable } from './retryer';\nimport { getAbortController } from './utils';\nexport function infiniteQueryBehavior() {\n  return {\n    onFetch: function onFetch(context) {\n      context.fetchFn = function () {\n        var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;\n\n        var refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;\n        var fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;\n        var pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;\n        var isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'forward';\n        var isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === 'backward';\n        var oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];\n        var oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];\n        var abortController = getAbortController();\n        var abortSignal = abortController == null ? void 0 : abortController.signal;\n        var newPageParams = oldPageParams;\n        var cancelled = false; // Get query function\n\n        var queryFn = context.options.queryFn || function () {\n          return Promise.reject('Missing queryFn');\n        };\n\n        var buildNewPages = function buildNewPages(pages, param, page, previous) {\n          newPageParams = previous ? [param].concat(newPageParams) : [].concat(newPageParams, [param]);\n          return previous ? [page].concat(pages) : [].concat(pages, [page]);\n        }; // Create function to fetch a page\n\n\n        var fetchPage = function fetchPage(pages, manual, param, previous) {\n          if (cancelled) {\n            return Promise.reject('Cancelled');\n          }\n\n          if (typeof param === 'undefined' && !manual && pages.length) {\n            return Promise.resolve(pages);\n          }\n\n          var queryFnContext = {\n            queryKey: context.queryKey,\n            signal: abortSignal,\n            pageParam: param,\n            meta: context.meta\n          };\n          var queryFnResult = queryFn(queryFnContext);\n          var promise = Promise.resolve(queryFnResult).then(function (page) {\n            return buildNewPages(pages, param, page, previous);\n          });\n\n          if (isCancelable(queryFnResult)) {\n            var promiseAsAny = promise;\n            promiseAsAny.cancel = queryFnResult.cancel;\n          }\n\n          return promise;\n        };\n\n        var promise; // Fetch first page?\n\n        if (!oldPages.length) {\n          promise = fetchPage([]);\n        } // Fetch next page?\n        else if (isFetchingNextPage) {\n            var manual = typeof pageParam !== 'undefined';\n            var param = manual ? pageParam : getNextPageParam(context.options, oldPages);\n            promise = fetchPage(oldPages, manual, param);\n          } // Fetch previous page?\n          else if (isFetchingPreviousPage) {\n              var _manual = typeof pageParam !== 'undefined';\n\n              var _param = _manual ? pageParam : getPreviousPageParam(context.options, oldPages);\n\n              promise = fetchPage(oldPages, _manual, _param, true);\n            } // Refetch pages\n            else {\n                (function () {\n                  newPageParams = [];\n                  var manual = typeof context.options.getNextPageParam === 'undefined';\n                  var shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true; // Fetch first page\n\n                  promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0])); // Fetch remaining pages\n\n                  var _loop = function _loop(i) {\n                    promise = promise.then(function (pages) {\n                      var shouldFetchNextPage = refetchPage && oldPages[i] ? refetchPage(oldPages[i], i, oldPages) : true;\n\n                      if (shouldFetchNextPage) {\n                        var _param2 = manual ? oldPageParams[i] : getNextPageParam(context.options, pages);\n\n                        return fetchPage(pages, manual, _param2);\n                      }\n\n                      return Promise.resolve(buildNewPages(pages, oldPageParams[i], oldPages[i]));\n                    });\n                  };\n\n                  for (var i = 1; i < oldPages.length; i++) {\n                    _loop(i);\n                  }\n                })();\n              }\n\n        var finalPromise = promise.then(function (pages) {\n          return {\n            pages: pages,\n            pageParams: newPageParams\n          };\n        });\n        var finalPromiseAsAny = finalPromise;\n\n        finalPromiseAsAny.cancel = function () {\n          cancelled = true;\n          abortController == null ? void 0 : abortController.abort();\n\n          if (isCancelable(promise)) {\n            promise.cancel();\n          }\n        };\n\n        return finalPromise;\n      };\n    }\n  };\n}\nexport function getNextPageParam(options, pages) {\n  return options.getNextPageParam == null ? void 0 : options.getNextPageParam(pages[pages.length - 1], pages);\n}\nexport function getPreviousPageParam(options, pages) {\n  return options.getPreviousPageParam == null ? void 0 : options.getPreviousPageParam(pages[0], pages);\n}\n/**\n * Checks if there is a next page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasNextPage(options, pages) {\n  if (options.getNextPageParam && Array.isArray(pages)) {\n    var nextPageParam = getNextPageParam(options, pages);\n    return typeof nextPageParam !== 'undefined' && nextPageParam !== null && nextPageParam !== false;\n  }\n}\n/**\n * Checks if there is a previous page.\n * Returns `undefined` if it cannot be determined.\n */\n\nexport function hasPreviousPage(options, pages) {\n  if (options.getPreviousPageParam && Array.isArray(pages)) {\n    var previousPageParam = getPreviousPageParam(options, pages);\n    return typeof previousPageParam !== 'undefined' && previousPageParam !== null && previousPageParam !== false;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}